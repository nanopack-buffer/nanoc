package swiftgen

import "nanoc/internal/npschema"

type messageClassTemplateInfo struct {
	Schema *npschema.Message

	FieldDeclarationLines []string
	ConstructorParameters []string
	FieldInitializers     []string
	SuperConstructorArgs  []string

	ReadPtrStart           int
	FieldReadCodeFragments []string

	InitialWriteBufferSize  int
	FieldWriteCodeFragments []string
}

type messageFactoryTemplateInfo struct {
	Schemas []*npschema.Message
}

type enumTemplateInfo struct {
	EnumName           string
	SwiftValueTypeName string
	MemberDeclarations []string
}

type serviceTemplateInfo struct {
	Schema *npschema.Service
}

const extSwift = ".np.swift"

const (
	templateNameMessageClass = "SwiftMessageClass"

	templateNameMessageFactory = "SwiftMessageFactory"

	templateNameEnum = "SwiftEnum"

	templateNameServiceServer = "SwiftServiceServer"
)

const fileNameMessageFactoryFile = "NanoPackMessageFactory"

const messageClassTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import Foundation
import NanoPack

let {{.Schema.Name}}_typeID: TypeID = {{.Schema.TypeID}}

class {{.Schema.Name}}: {{if .Schema.HasParentMessage}}{{.Schema.ParentMessage.Name}}{{else}}NanoPackMessage{{end}} {
    {{if .Schema.HasParentMessage}}override{{end}} var typeID: TypeID { return {{.Schema.TypeID}} }

    {{if .Schema.HasParentMessage}}override{{end}} var headerSize: Int { return {{.Schema.HeaderSize}} }

    {{range .FieldDeclarationLines}}
    {{.}}
    {{- end}}

    {{if .Schema.IsInherited}}
    static func from(data: Data) -> {{.Schema.Name}}? {
        switch data.readTypeID() {
        case {{.Schema.TypeID}}: return {{.Schema.Name}}(data: data)
        {{range .Schema.ChildMessages -}}
        case {{.TypeID}}: return {{.Name}}(data: data)
        {{- end}}
        default: return nil
        }
    }
    
    static func from(data: Data, bytesRead: inout Int) -> {{.Schema.Name}}? {
        switch data.readTypeID() {
        case {{.Schema.TypeID}}: return {{.Schema.Name}}(data: data, bytesRead: &bytesRead)
        {{range .Schema.ChildMessages -}}
        case {{.TypeID}}: return {{.Name}}(data: data, bytesRead: &bytesRead)
        {{- end}}
        default: return nil
        }
    }
    {{end}}

    init({{join .ConstructorParameters ", "}}) {
        {{- range .FieldInitializers}}
        {{.}}
        {{- end -}}
        {{if .Schema.HasParentMessage}}
        super.init({{join .SuperConstructorArgs ", "}})
        {{- end}}
    }

    required init?(data: Data) {
        var ptr = data.startIndex + {{.ReadPtrStart}}

        {{range .FieldReadCodeFragments}}
        {{.}}

        {{end}}

        {{range .FieldInitializers}}
        {{.}}
        {{- end -}}
        {{if .Schema.HasParentMessage}}
        super.init({{join .SuperConstructorArgs ", "}})
        {{- end}}
    }

    required init?(data: Data, bytesRead: inout Int) {
        var ptr = data.startIndex + {{.ReadPtrStart}}

        {{range .FieldReadCodeFragments}}
        {{.}}

        {{end}}

		{{range .FieldInitializers}}
        {{.}}
        {{- end -}}
        {{if .Schema.HasParentMessage}}
        super.init({{join .SuperConstructorArgs ", "}})
        {{- end}}

        bytesRead = ptr - data.startIndex
    }

    {{if .Schema.HasParentMessage}}override{{end}} func write(to data: inout Data, offset: Int) -> Int {
        let dataCountBefore = data.count

		data.reserveCapacity(offset + {{.InitialWriteBufferSize}})

		data.append(typeID: TypeID({{.Schema.Name}}_typeID))
		data.append([0], count: {{len .Schema.AllFields}} * 4)

        {{range .FieldWriteCodeFragments}}
        {{.}}

        {{end}}

        return data.count - dataCountBefore
    }

    {{if .Schema.HasParentMessage}}override{{end}} func data() -> Data? {
        var data = Data()
        _ = write(to: &data, offset: 0)
        return data
    }
}
`

const messageFactoryTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import Foundation
import NanoPack

func makeNanoPackMessage(from data: Data) -> NanoPackMessage? {
    let typeID = data.readTypeID()
    switch typeID {
    {{- range .Schemas}}
    case {{.TypeID}}: return {{.Name}}(data: data)
    {{- end}}
    default: return nil
    }
}

func makeNanoPackMessage(from data: Data, bytesRead: inout Int) -> NanoPackMessage? {
    let typeID = data.readTypeID()
    switch typeID {
    {{- range .Schemas}}
    case {{.TypeID}}: return {{.Name}}(data: data, bytesRead: &bytesRead)
    {{- end}}
    default: return nil
    }
}
`

const enumTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import Foundation

enum {{.EnumName}}: {{.SwiftValueTypeName}} {
{{- range .MemberDeclarations}}
{{.}}
{{- end}}
}
`

const serviceTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import Foundation
import NanoPack

protocol {{.Schema.Name}}ServiceDelegate {
	{{- range .Schema.DeclaredFunctions}}
	func {{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}_ {{$param.Name}}: {{typeDeclaration $param.Type}}{{end}}){{if .ReturnType}} -> {{typeDeclaration .ReturnType}}{{end}}
	{{- end}}
}

class {{.Schema.Name}}ServiceServer: NPRPCServer {
	private let delegate: {{.Schema.Name}}ServiceDelegate

	init(channel: NPRPCServerChannel, delegate: {{.Schema.Name}}ServiceDelegate) {
		self.delegate = delegate
		super.init(channel: channel)
		registerCalls()
	}

	private func registerCalls() {
		{{- range .Schema.DeclaredFunctions}}
		on("{{.Name}}") { data, offset, msgID in
			var ptr = offset
			{{generateReadParamCode .}}
			let result = self.delegate.{{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name}}{{end}})
			var data = Data(capacity: {{if gt .ReturnType.ByteSize 0 }}6 + {{.ReturnType.ByteSize}}{{else}}6{{end}})
			data.append(int: NPRPCMessageType.response.rawValue)
			data.append(int: msgID)
			data.append(int: UInt8(0))
			{{generateWriteResultCode .}}
			return data
		}
		{{- end}}
	}
}

class {{.Schema.Name}}ServiceClient: NPRPCClient {
	override init(channel: NPRPCClientChannel) {
		super.init(channel: channel)
	}

	{{range .Schema.DeclaredFunctions}}
	func {{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}_ {{$param.Name}}: {{typeDeclaration $param.Type}}{{end}}, completionHandler: @escaping ({{if .ReturnType}}{{typeDeclaration .ReturnType}}{{end}}) -> Void) {
		let msgID = newMessageID()
		var data = Data(capacity: 9 + {{stringByteSize .Name}}{{if gt .ParametersByteSize 0}} + {{.ParametersByteSize}}{{end}})
		data.append(int: NPRPCMessageType.request.rawValue)
		data.append(int: msgID)
		data.append(int: UInt32({{stringByteSize .Name}}))
		data.append(string: "{{.Name}}")
		{{generateWriteParamCode .}}
		sendRequestData(msgID, data) { data, offset in
			var ptr = offset
			let errFlag: UInt8 = data.read(at: ptr)
			ptr += 1
			guard errFlag == 0 else {
				return
			}
			{{- if .ReturnType}}
			{{generateReadResultCode .}}
			completionHandler(result)
			{{- else}}
			completionHandler()
			{{- end}}
		}
	}

	@available(macOS 10.15, iOS 13, *)
	func {{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}_ {{$param.Name}}: {{typeDeclaration $param.Type}}{{end}}) async{{if .ReturnType}} -> {{typeDeclaration .ReturnType}}{{end}} {
		let msgID = newMessageID()
		var data = Data(capacity: 9 + {{stringByteSize .Name}}{{if gt .ParametersByteSize 0}} + {{.ParametersByteSize}}{{end}})
		data.append(int: NPRPCMessageType.request.rawValue)
		data.append(int: msgID)
		data.append(int: UInt32({{stringByteSize .Name}}))
		data.append(string: "{{.Name}}")
		{{generateWriteParamCode .}}
		return await withCheckedContinuation { continuation in
			sendRequestData(msgID, data) { data, offset in
				var ptr = offset
				let errFlag: UInt8 = data.read(at: ptr)
				ptr += 1
				guard errFlag == 0 else {
					return
				}
				{{- if .ReturnType}}
				{{generateReadResultCode .}}
				continuation.resume(returning: result)
				{{- else}}
				continuation.resume()
				{{- end}}
			}
		}
	}
	{{end -}}
}
`
