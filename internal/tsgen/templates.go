package tsgen

import "nanoc/internal/npschema"

type messageClassTemplateInfo struct {
	Schema          *npschema.Message
	ExternalImports []string

	ConstructorParameters []string
	ConstructorArgs       []string
	SuperConstructorArgs  []string

	FieldReadCodeFragments  []string
	FieldWriteCodeFragments []string
}

type messageClassFactoryTemplateInfo struct {
	Schema             *npschema.Message
	MessageClassImport string
	MessageImports     []string
}

type messageFactoryTemplateInfo struct {
	Schemas        []*npschema.Message
	MessageImports []string
}

type enumTemplateInfo struct {
	Schema             *npschema.Enum
	MemberDeclarations []string
}

type serviceTemplateInfo struct {
	Schema          *npschema.Service
	ExternalImports []string
}

const (
	extImport = ".np.js"

	extTsFile = ".np.ts"
)

const (
	templateNameMessageClass = "TsMessageClass"

	templateNameMessageClassFactory = "TsMessageClassFactory"

	templateNameMessageFactory = "TsMessageFactory"

	templateNameEnum = "TsEnum"

	templateNameService = "TsService"
)

const fileNameMessageFactoryFile = "message-factory.np.ts"

const messageClassTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import { NanoBufReader, NanoBufWriter{{if not .Schema.HasParentMessage}}, type NanoPackMessage{{end}} } from "nanopack";

{{range .ExternalImports}}
{{.}}
{{- end}}

class {{.Schema.Name}} {{if .Schema.HasParentMessage}}extends {{.Schema.ParentMessage.Name}}{{else}}implements NanoPackMessage{{end}} {
  public static TYPE_ID = {{.Schema.TypeID}};

  public {{if .Schema.HasParentMessage}}override {{end}}readonly typeId: number = {{.Schema.TypeID}};

  public {{if .Schema.HasParentMessage}}override {{end}}readonly headerSize: number = {{.Schema.HeaderSize}};

  {{if .Schema.HasParentMessage -}}
  constructor({{join .ConstructorParameters ", "}}) {
    super({{join .SuperConstructorArgs ", "}})
  }
  {{else}}
  constructor({{join .ConstructorParameters ", "}}) {}
  {{- end}}

  public static fromBytes(bytes: Buffer): { bytesRead: number, result: {{.Schema.Name}} } | null {
    const reader = new NanoBufReader(bytes);
    return {{.Schema.Name}}.fromReader(reader);
  }

  public static fromReader(reader: NanoBufReader, offset = 0): { bytesRead: number, result: {{.Schema.Name}} } | null {
    let ptr = offset + {{.Schema.HeaderSize}};

    {{range .FieldReadCodeFragments}}
    {{.}}

    {{end}}

    return { bytesRead: ptr - offset, result: new {{.Schema.Name}}({{join .ConstructorArgs ", "}}) };
  }

  {{if .Schema.HasParentMessage}}override {{end}}public writeTo(writer: NanoBufWriter, offset = 0): number {
    let bytesWritten = {{.Schema.HeaderSize}};

    writer.writeTypeId({{.Schema.TypeID}}, offset);

    {{range .FieldWriteCodeFragments}}
    {{.}}

    {{end}}

    return bytesWritten;
  }

  {{if .Schema.HasParentMessage}}override {{end}}public bytes(): Uint8Array {
    const writer = new NanoBufWriter({{.Schema.HeaderSize}});
    this.writeTo(writer)
    return writer.bytes;
  }
}

export { {{.Schema.Name}} };
`

const messageClassFactoryTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import { NanoBufReader } from "nanopack";

import { {{.Schema.Name}} } from "{{.MessageClassImport}}";
{{range .MessageImports -}}
{{.}}
{{- end}}

function make{{.Schema.Name}}(reader: NanoBufReader, offset = 0): { bytesRead: number, result: {{.Schema.Name}} } | null {
  switch (reader.readTypeId(offset)) {
  case {{.Schema.TypeID}}: return {{.Schema.Name}}.fromReader(reader, offset);
  {{- range .Schema.ChildMessages}}
  case {{.TypeID}}: return {{.Name}}.fromReader(reader, offset);
  {{- end}}
  default: return null;
  }
}

export { make{{.Schema.Name}} } ;
`

const messageFactoryTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import { NanoBufReader, type NanoPackMessage } from "nanopack";
{{range .MessageImports}}
{{.}}
{{- end}}

function makeNanoPackMessage(reader: NanoBufReader, offset = 0): { bytesRead: number, result: NanoPackMessage } | null {
  switch (reader.readTypeId(offset)) {
  {{range .Schemas}}
  case {{.TypeID}}: return {{.Name}}.fromReader(reader, offset);
  {{- end}}
  default: return null;
  }
}

export { makeNanoPackMessage }
`

const enumTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

const {{.Schema.Name}} = {
  {{range .MemberDeclarations}}
  {{.}},
  {{- end}}
} as const;

type T{{.Schema.Name}} = typeof {{.Schema.Name}}[keyof typeof {{.Schema.Name}}];

export { {{.Schema.Name}} };
export type { T{{.Schema.Name}} };
`

const serviceTemplate = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import { NanoBufWriter } from "nanopack";
import { RpcServer, RpcClient, RpcMessageType, type RpcServerChannel } from "nanopack/rpc";

{{range .ExternalImports}}
{{.}}
{{- end}}

interface I{{.Schema.Name}}Service {
	{{- range .Schema.DeclaredFunctions}}
	{{lowerCamel .Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name}}: {{typeDeclaration $param.Type}}{{end}}): {{if .ReturnType}}{{typeDeclaration .ReturnType}}{{else}}void{{end}};
	{{- end}}
};

class {{.Schema.Name}}ServiceServer extends RpcServer {
	constructor(channel: RpcServerChannel, private impl: I{{.Schema.Name}}Service) {
		super(channel);

		{{- range .Schema.DeclaredFunctions}}
		this.on("{{.Name}}", (reader, offset, msgId) => {
			let ptr = offset;
			{{generateReadParamCode .}}
			{{if .ReturnType}}const result = {{end}}this.impl.{{lowerCamel .Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name}}{{end}});
			const writer = new NanoBufWriter(6{{if and .ReturnType (gt .ReturnType.ByteSize 0)}} + {{.ReturnType.ByteSize}}{{end}})
			writer.appendUint8(RpcMessageType.RESPONSE);
			writer.appendUint32(msgId);
			writer.appendUint8(0);
			{{if .ReturnType}}{{generateWriteResultCode .}}{{end}}
			return writer;
		});
		{{- end}}
	}
}

class {{.Schema.Name}}ServiceClient extends RpcClient {
	{{- range .Schema.DeclaredFunctions}}
	async {{lowerCamel .Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name}}: {{typeDeclaration $param.Type}}{{end}}): Promise<{{if .ReturnType}}{{typeDeclaration .ReturnType}}{{else}}void{{end}}> {
		const writer = new NanoBufWriter(9 + {{stringByteSize .Name}}{{if gt .ParametersByteSize 0}} + {{.ParametersByteSize}}{{end}})
		const msgId = this.newMessageId();
		writer.appendUint8(RpcMessageType.REQUEST);
		writer.appendUint32(msgId);
		writer.appendStringAndSize("{{.Name}}");
		{{generateWriteParamCode .}}
		const reader = await this.sendRequestData(msgId, writer.bytes);
		let ptr = 5;
		const errFlag = reader.readUint8(ptr++);
		if (errFlag) {
			throw new Error("error")
		}
		{{if .ReturnType}}
		{{generateReadResultCode .}}
		return result;
		{{end}}
	}
	{{- end}}
}

export { {{.Schema.Name}}ServiceServer, {{.Schema.Name}}ServiceClient };
export type { I{{.Schema.Name}}Service };
`
