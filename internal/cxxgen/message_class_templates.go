package cxxgen

import "nanoc/internal/npschema"

type messageHeaderFileTemplateInfo struct {
	MessageName       string
	HasParentMessage  bool
	ParentMessageName string
	TypeID            int
	IncludeGuardName  string
	LibraryImports    []string
	RelativeImports   []string
	IsInherited       bool

	FieldDeclarationLines []string
	ConstructorParameters []string
}

type messageImplFileTemplateInfo struct {
	HeaderName        string
	MessageName       string
	HasParentMessage  bool
	ParentMessageName string

	ConstructorParameters []string
	SuperConstructorArgs  []string
	FieldInitializers     []string

	ReadPtrStart           int
	InitialWriteBufferSize int

	FieldReadCodeFragments  []string
	FieldWriteCodeFragments []string
}

type messageFactoryImplFileTemplateInfo struct {
	MessageImportPaths []string
	MessageSchemas     []*npschema.Message
}

const (
	templateNameMessageHeaderFile      = "CxxMessageHeaderFile"
	templateNameMessageImplFile        = "CxxMessageImplFile"
	templateNameMessageFactoryImplFile = "CxxMessageFactoryImplFile"
)

const (
	extHeaderFile = ".np.hxx"
	extImplFile   = ".np.cxx"
)

const fileNameMessageFactory = "nanopack_message_factory"

const messageHeaderFile = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

#ifndef {{.IncludeGuardName}}
#define {{.IncludeGuardName}}

#include <vector>
{{- range .LibraryImports}}
#include <{{.}}>
{{- end}}
{{- if not .HasParentMessage}}
#include <nanopack/message.hxx>
{{- end}}
#include <nanopack/reader.hxx>

{{range .RelativeImports}}
#inlcude "{{.}}"
{{- end}}

struct {{.MessageName}} : {{if .HasParentMessage}}{{.ParentMessageName}}{{else}}NanoPack::Message{{end}} {
  static constexpr int32_t TYPE_ID = {{.TypeID}};

  {{range .FieldDeclarationLines}}{{.}}{{end}}

  {{- if .IsInherited}}
  static std::unique_ptr<{{.MessageName}}> from (std::vector<uint8_t>::const_iterator begin, int &bytes_read);
  {{end}}

  {{.MessageName}}() = default;

  {{$l := len .ConstructorParameters}}{{if eq $l 1}}explicit {{end}}
  {{- .MessageName}}({{range $i, $v := .ConstructorParameters}}{{if $i}}, {{end}}{{$v}}{{end}});

  {{.MessageName}}(std::vector<uint8_t>::const_iterator begin, int &bytes_read);

  {{.MessageName}}(const NanoPack::Reader &reader, int &bytes_read);

  [[nodiscard]] std::vector<uint8_t> data() const override;
};

#endif
`
const messageImplFile = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

#include <nanopack/reader.hxx>
#include <nanopack/writer.hxx>

#include "{{.HeaderName}}"

{{.MessageName}}::{{.MessageName}}({{join .ConstructorParameters ", "}}) :
  {{if .HasParentMessage}}{{.ParentMessageName}}({{join .SuperConstructorArgs}}), {{end}}
  {{- join .FieldInitializers ", "}} {}

{{.MessageName}}::{{.MessageName}}(const NanoPack::Reader &reader, int &bytes_read) {{if .HasParentMessage}}: {{.ParentMessageName}}(){{end}} {
  const auto begin = reader.begin();
  int ptr = {{.ReadPtrStart}};

  {{range .FieldReadCodeFragments}}
  {{.}}

  {{end}}

  bytes_read = ptr;
}

{{.MessageName}}::{{.MessageName}}(std::vector<uint8_t>::const_iterator begin, int &bytes_read) :
  {{.MessageName}}(NanoPack::Reader(begin), bytes_read) {}

std::vector<uint8_t> {{.MessageName}}::data() const {
  std::vector<uint8_t> buf({{.InitialWriteBufferSize}});
  NanoPack::Writer writer(&buf);

  writer.write_type_id(TYPE_ID);

  {{range .FieldWriteCodeFragments}}
  {{.}}

  {{end}}

  return buf;
}
`

const messageFactoryHeaderFile = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

#ifndef NANOPACK_MESSAGE_FACTORY_HXX
#define NANOPACK_MESSAGE_FACTORY_HXX

#include <nanopack/message.hxx>
#include <memory>

std::unique_ptr<NanoPack::Message> make_nanopack_message(int32_t type_id, std::vector<uint8_t>::const_iterator data_iter, int &bytes_read);

#endif
`

const messageFactoryImplFile = `// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

#include "nanopack_message_factory.hxx"

{{range .MessageImportPaths}}
#include "{{.}}"
{{- end}}

std::unique_ptr<NanoPack::Message> make_nanopack_message(int32_t type_id, std::vector<uint8_t>::const_iterator data_iter, int &bytes_read) {
  switch (type_id) {
  {{range .MessageSchemas -}}
  case {{.TypeID}}: return std::make_unique<{{.Name}}>(data_iter, bytes_read);
  {{- end}}
  default: return nullptr;
  }
}
`
