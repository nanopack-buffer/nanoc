// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

import { NanoBufReader, NanoBufWriter, type NanoPackMessage } from "nanopack";

import { makeNanoPackMessage } from "./message-factory.np.js";

class SimpleMessage implements NanoPackMessage {
  public static TYPE_ID = 3338766369;

  public readonly typeId: number = 3338766369;

  public readonly headerSize: number = 32;

  constructor(
    public stringField: string,
    public intField: number,
    public doubleField: number,
    public optionalField: string | null,
    public arrayField: number[],
    public mapField: Map<string, boolean>,
    public anyMessage: NanoPackMessage,
  ) {}

  public static fromBytes(
    bytes: Uint8Array,
  ): { bytesRead: number; result: SimpleMessage } | null {
    const reader = new NanoBufReader(bytes);
    return SimpleMessage.fromReader(reader);
  }

  public static fromReader(
    reader: NanoBufReader,
    offset = 0,
  ): { bytesRead: number; result: SimpleMessage } | null {
    let ptr = offset + 32;

    const stringFieldByteLength = reader.readFieldSize(0, offset);
    const stringField = reader.readString(ptr, stringFieldByteLength);
    ptr += stringFieldByteLength;

    const intField = reader.readInt32(ptr);
    ptr += 4;

    const doubleField = reader.readDouble(ptr);
    ptr += 8;

    let optionalField: string | null;
    if (reader.readFieldSize(3, offset) >= 0) {
      const optionalFieldByteLength = reader.readFieldSize(3, offset);
      optionalField = reader.readString(ptr, optionalFieldByteLength);
      ptr += optionalFieldByteLength;
    } else {
      optionalField = null;
    }

    const arrayFieldByteLength = reader.readFieldSize(4, offset);
    const arrayFieldLength = arrayFieldByteLength / 1;
    const arrayField: number[] = new Array(arrayFieldLength);
    for (let i = 0; i < arrayFieldLength; i++) {
      const iItem = reader.readUint8(ptr);
      ptr += 1;
      arrayField[i] = iItem;
    }

    const mapField = new Map<string, boolean>();
    const mapFieldItemCount = reader.readInt32(ptr);
    ptr += 4;
    for (let i = 0; i < mapFieldItemCount; i++) {
      const iKeyByteLength = reader.readInt32(ptr);
      ptr += 4;
      const iKey = reader.readString(ptr, iKeyByteLength);
      ptr += iKeyByteLength;
      const iItem = reader.readBoolean(ptr++);
      mapField.set(iKey, iItem);
    }

    const maybeAnyMessage = makeNanoPackMessage(reader, ptr);
    if (!maybeAnyMessage) {
      return null;
    }
    const anyMessage = maybeAnyMessage.result;
    ptr += maybeAnyMessage.bytesRead;

    return {
      bytesRead: ptr - offset,
      result: new SimpleMessage(
        stringField,
        intField,
        doubleField,
        optionalField,
        arrayField,
        mapField,
        anyMessage,
      ),
    };
  }

  public writeTo(writer: NanoBufWriter, offset = 0): number {
    let bytesWritten = 32;

    writer.writeTypeId(3338766369, offset);

    const stringFieldByteLength = writer.appendString(this.stringField);
    writer.writeFieldSize(0, stringFieldByteLength, offset);
    bytesWritten += stringFieldByteLength;

    writer.appendInt32(this.intField);
    writer.writeFieldSize(1, 4, offset);
    bytesWritten += 4;

    writer.appendDouble(this.doubleField);
    writer.writeFieldSize(2, 8, offset);
    bytesWritten += 8;

    if (this.optionalField) {
      const optionalFieldByteLength = writer.appendString(this.optionalField);
      writer.writeFieldSize(3, optionalFieldByteLength, offset);
      bytesWritten += optionalFieldByteLength;
    } else {
      writer.writeFieldSize(3, -1, offset);
    }

    const arrayFieldByteLength = this.arrayField.length * 1;
    writer.writeFieldSize(4, arrayFieldByteLength, offset);
    for (const arrayField of this.arrayField) {
      writer.appendUint8(arrayField);
    }
    bytesWritten += arrayFieldByteLength;

    writer.appendInt32(this.mapField.size);
    let mapFieldByteLength = 4;
    this.mapField.forEach((iItem, iKey) => {
      const iKeyByteLength = writer.appendStringAndSize(iKey);
      writer.appendBoolean(iItem);
      mapFieldByteLength += iKeyByteLength + 4 + 1;
    });
    bytesWritten += mapFieldByteLength;
    writer.writeFieldSize(5, mapFieldByteLength, offset);

    const anyMessageWriteOffset = writer.currentSize;
    writer.reserveHeader(this.anyMessage.headerSize);
    const anyMessageByteSize = this.anyMessage.writeTo(
      writer,
      anyMessageWriteOffset,
    );
    writer.writeFieldSize(6, anyMessageByteSize, offset);
    bytesWritten += anyMessageByteSize;

    return bytesWritten;
  }

  public bytes(): Uint8Array {
    const writer = new NanoBufWriter(32);
    this.writeTo(writer);
    return writer.bytes;
  }
}

export { SimpleMessage };
