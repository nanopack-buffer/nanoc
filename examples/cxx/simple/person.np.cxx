// AUTOMATICALLY GENERATED BY NANOPACK. DO NOT MODIFY BY HAND.

#include <nanopack/reader.hxx>
#include <nanopack/writer.hxx>

#include "person.np.hxx"

Person::Person(std::string first_name, std::optional<std::string> middle_name,
               std::string last_name, int8_t age,
               std::shared_ptr<Person> other_friend)
    : first_name(std::move(first_name)), middle_name(std::move(middle_name)),
      last_name(std::move(last_name)), age(age),
      other_friend(std::move(other_friend)) {}

Person::Person(const NanoPack::Reader &reader, int &bytes_read) {
  const auto begin = reader.begin();
  int ptr = 24;

  const int32_t first_name_size = reader.read_field_size(0);
  first_name = reader.read_string(ptr, first_name_size);
  ptr += first_name_size;

  if (reader.read_field_size(1) < 0) {
    this->middle_name = std::nullopt;
  } else {
    const int32_t middle_name_size = reader.read_field_size(1);
    middle_name = reader.read_string(ptr, middle_name_size);
    ptr += middle_name_size;
  }

  const int32_t last_name_size = reader.read_field_size(2);
  last_name = reader.read_string(ptr, last_name_size);
  ptr += last_name_size;

  const int8_t age = reader.read_int8(ptr);
  ptr += 1;
  this->age = age;

  if (reader.read_field_size(4) < 0) {
    other_friend = nullptr;
  } else {
    int other_friend_bytes_read = 0;
    other_friend =
        std::make_shared<Person>(begin + ptr, other_friend_bytes_read);
    ptr += other_friend_bytes_read;
  }

  bytes_read = ptr;
}

Person::Person(std::vector<uint8_t>::const_iterator begin, int &bytes_read)
    : Person(NanoPack::Reader(begin), bytes_read) {}

NanoPack::TypeId Person::type_id() const { return TYPE_ID; }

int Person::header_size() const { return 24; }

size_t Person::write_to(std::vector<uint8_t> &buf, int offset) const {
  const size_t buf_size_before = buf.size();

  buf.resize(offset + 24);

  NanoPack::write_type_id(TYPE_ID, offset, buf);

  NanoPack::write_field_size(0, first_name.size(), offset, buf);
  NanoPack::append_string(first_name, buf);

  if (middle_name.has_value()) {
    const auto middle_name = this->middle_name.value();
    NanoPack::write_field_size(1, middle_name.size(), offset, buf);
    NanoPack::append_string(middle_name, buf);
  } else {
    NanoPack::write_field_size(1, -1, offset, buf);
  }

  NanoPack::write_field_size(2, last_name.size(), offset, buf);
  NanoPack::append_string(last_name, buf);

  NanoPack::write_field_size(3, 1, offset, buf);
  NanoPack::append_int8(age, buf);

  if (other_friend != nullptr) {
    const size_t before_other_friend_size = buf.size();
    other_friend->write_to(buf, before_other_friend_size);
    NanoPack::write_field_size(4, buf.size() - before_other_friend_size, offset,
                               buf);
  } else {
    NanoPack::write_field_size(4, -1, offset, buf);
  }

  return buf.size() - buf_size_before;
}

std::vector<uint8_t> Person::data() const {
  std::vector<uint8_t> buf(24);
  write_to(buf, 0);
  return buf;
}
