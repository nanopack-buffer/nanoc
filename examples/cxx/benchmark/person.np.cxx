// AUTOMATICALLY GENERATED BY NANOC

#include <nanopack/reader.hxx>
#include <nanopack/writer.hxx>

#include "person.np.hxx"

Person::Person(std::string first_name, std::optional<std::string> middle_name,
               std::string last_name, int8_t age, std::vector<Person> friends)
    : first_name(std::move(first_name)), middle_name(std::move(middle_name)),
      last_name(std::move(last_name)), age(age), friends(std::move(friends)) {}

size_t Person::read_from(NanoPack::Reader &reader) {
  uint8_t *buf = reader.buffer;
  int ptr = 24;

  const int32_t first_name_size = reader.read_field_size(0);
  reader.read_string(ptr, first_name_size, first_name);
  ptr += first_name_size;

  if (reader.read_field_size(1) < 0) {
    middle_name = std::nullopt;
  } else {
    middle_name = std::move(std::string());
    const int32_t middle_name_size = reader.read_field_size(1);
    reader.read_string(ptr, middle_name_size, middle_name);
    ptr += middle_name_size;
  }

  const int32_t last_name_size = reader.read_field_size(2);
  reader.read_string(ptr, last_name_size, last_name);
  ptr += last_name_size;

  reader.read_int8(ptr, age);
  ptr += 1;

  int32_t friends_vec_size;
  reader.read_int32(ptr, friends_vec_size);
  ptr += 4;
  friends.resize(friends_vec_size);
  for (int i = 0; i < friends_vec_size; ++i) {
    auto &i_item = friends[i];
    reader.buffer += ptr;
    const size_t i_item_bytes_read = i_item.read_from(reader);
    reader.buffer = buf;
    ptr += i_item_bytes_read;
  }

  return ptr;
}

NanoPack::TypeId Person::type_id() const { return TYPE_ID; }

size_t Person::header_size() const { return 24; }

size_t Person::write_to(NanoPack::Writer &writer, int offset) const {
  const size_t writer_size_before = writer.size();

  writer.reserve_header(24);

  writer.write_type_id(TYPE_ID, offset);

  writer.write_field_size(0, first_name.size(), offset);
  writer.append_string(first_name);

  if (middle_name.has_value()) {
    writer.write_field_size(1, middle_name->size(), offset);
    writer.append_string(*middle_name);
  } else {
    writer.write_field_size(1, -1, offset);
  }

  writer.write_field_size(2, last_name.size(), offset);
  writer.append_string(last_name);

  writer.write_field_size(3, 1, offset);
  writer.append_int8(age);

  const size_t friends_vec_size = friends.size();
  writer.append_int32(friends_vec_size);
  int32_t friends_byte_size = sizeof(int32_t);
  for (auto &i : friends) {
    const size_t i_byte_size = i.write_to(writer, writer.size());
    friends_byte_size += i_byte_size;
  }
  writer.write_field_size(4, friends_byte_size, offset);

  return writer.size() - writer_size_before;
}
